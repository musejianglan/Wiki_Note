Java基本语法、面向对象相关的基本概念与思想<br/>
常用String类的api<br/>
异常处理<br/>
IO基础<br/>
容器<br/>
多线程<br/>
内存管理与垃圾回收<br/>
知道并最好知道几种常见的 Java 设计模式<br/>

Android基础UI控件的熟练掌握<br/>
(Button、TextView、EditText、CheckBox、RadioButton、ImageView、Spinner、ProgressBar、SeekBar、ListView、RecycleView、ScrollView)

## Activity的生命周期<br/>
![](activity_lifetime.gif)
![](activity2.png)
```
public class Activity extends ApplicationContext {  
       //创建Activity
       public void onCreate(Bundle savedInstanceState) {
               super.onCreate(savedInstanceState);
           }
       //Activity快要变成可见的
           @Override
           protected void onStart() {
               super.onStart();
           }
       //Activity变成可见的，处于运行状态
           @Override
           protected void onResume() {
               super.onResume();
           }
       //其他Activity获得用户焦点，（Activity快要暂停了）
           @Override
           protected void onPause() {
               super.onPause();
           }
       //Activity不再可见，处于停止状态
           @Override
           protected void onStop() {
               super.onStop();
           }
       //Activity快要被销毁了
           @Override
           protected void onDestroy() {
               super.onDestroy()；
          ｝    
         // 重新获得可见
       protected void onRestart(){
            super.onRestart();
       };  
         
   }  
```
Activity的四种启动模式:startan<br/>
> 分别为standard，singleTop，singleTask，singleInstance。如果要使用这四种启动模式，
必须在manifest文件中<activity>标签中的launchMode属性中配置  
standard
标准启动模式，也是activity的默认启动模式。在这种模式下启动的activity可以被多次实例化，
即在同一个任务中可以存在多个activity的实例，每个实例都会处理一个Intent对象。
如果Activity A的启动模式为standard，并且A已经启动，在A中再次启动Activity A，
即调用startActivity（new Intent（this，A.class）），会在A的上面再次启动一个A的实例，即当前的桟中的状态为A-->A。
singleTop
如果一个以singleTop模式启动的activity的实例已经存在于任务桟的桟顶，那么再启动这个Activity时，不会创建新的实例，
而是重用位于栈顶的那个实例，并且会调用该实例的onNewIntent()方法将Intent对象传递到这个实例中。
举例来说，如果A的启动模式为singleTop，并且A的一个实例已经存在于栈顶中，
那么再调用startActivity（new Intent（this，A.class））启动A时，不会再次创建A的实例，而是重用原来的实例，并且调用原来实例的onNewIntent()方法。
这是任务桟中还是这有一个A的实例。
如果以singleTop模式启动的activity的一个实例已经存在与任务桟中，但是不在桟顶，那么它的行为和standard模式相同，也会创建多个实例。
singleTask
谷歌的官方文档上称，如果一个activity的启动模式为singleTask，那么系统总会在一个新任务的最底部（root）启动这个activity，
并且被这个activity启动的其他activity会和该activity同时存在于这个新任务中。如果系统中已经存在这样的一个activity则会重用这个实例，
并且调用他的onNewIntent()方法。即，这样的一个activity在系统中只会存在一个实例。
其实官方文档中的这种说法并不准确，启动模式为singleTask的activity并不会总是开启一个新的任务。
singleInstance
总是在新的任务中开启，并且这个新的任务中有且只有这一个实例，也就是说被该实例启动的其他activity会自动运行于另一个任务中。
当再次启动该activity的实例时，会重用已存在的任务和实例。并且会调用这个实例的onNewIntent()方法，将Intent实例传递到该实例中。
和singleTask相同，同一时刻在系统中只会存在一个这样的Activity实例。



## Fragment的生命周期

fragment的生命周期<br/>
![](fragment1.png)

Fragment与Activity之间的关系<br/>
![](fragment_activity.png)  

1. 当一个fragment被创建的时候，它会经历以下状态.

onAttach()
onCreate()
onCreateView()
onActivityCreated()
2. 当这个fragment对用户可见的时候，它会经历以下状态。

onStart()
onResume()
3. 当这个fragment进入“后台模式”的时候，它会经历以下状态。

onPause()
onStop()
4. 当这个fragment被销毁了（或者持有它的activity被销毁了），它会经历以下状态。

onPause()
onStop()
onDestroyView()
onDestroy() // 本来漏掉类这个回调，感谢xiangxue336提出。
onDetach()
5. 就像activitie一样，在以下的状态中，可以使用Bundle对象保存一个fragment的对象。

onCreate()
onCreateView()
onActivityCreated()
6. fragments的大部分状态都和activitie很相似，但fragment有一些新的状态。

onAttached() —— 当fragment被加入到activity时调用（在这个方法中可以获得所在的activity）。
onCreateView() —— 当activity要得到fragment的layout时，调用此方法，fragment在其中创建自己的layout(界面)。
onActivityCreated() —— 当activity的onCreated()方法返回后调用此方法
onDestroyView() —— 当fragment中的视图被移除的时候，调用这个方法。
onDetach() —— 当fragment和activity分离的时候，调用这个方法。
一旦activity进入resumed状态（也就是running状态），你就可以自由地添加和删除fragment了。
因此，只有当activity在resumed状态时，fragment的生命周期才能独立的运转，其它时候是依赖于activity的生命周期变化的。


## BroadcastReceiver
> 面是Android Doc中关于BroadcastReceiver的概述：
  ①广播接收器是一个专注于接收广播通知信息，并做出对应处理的组件。很多广播是源自于系统代码的──比如，
  通知时区改变、电池电量低、拍摄了一张照片或者用户改变了语言选项。应用程序也可以进行广播──比如说，
  通知其它应用程序一些数据下载完成并处于可用状态。
  ②应用程序可以拥有任意数量的广播接收器以对所有它感兴趣的通知信息予以响应。所有的接收器均继承自BroadcastReceiver基类。
  ③广播接收器没有用户界面。然而，它们可以启动一个activity来响应它们收到的信息，或者用NotificationManager来通知用户。
  通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等等。
  一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。
Android中的广播事件有两种，一种就是系统广播事件，比如：ACTION_BOOT_COMPLETED（系统启动完成后触发），
ACTION_TIME_CHANGED（系统时间改变时触发），ACTION_BATTERY_LOW（电量低时触发）等等。另外一种是我们自定义的广播事件。
广播事件的流程
  ①注册广播事件：注册方式有两种，一种是静态注册，就是在AndroidManifest.xml文件中定义，注册的广播接收器必须要继承BroadcastReceiver；
  另一种是动态注册，是在程序中使用Context.registerReceiver注册，注册的广播接收器相当于一个匿名类。两种方式都需要IntentFIlter。
  ②发送广播事件：通过Context.sendBroadcast来发送，由Intent来传递注册时用到的Action。
  ③接收广播事件：当发送的广播被接收器监听到后，会调用它的onReceive()方法，
  并将包含消息的Intent对象传给它。onReceive中代码的执行时间不要超过5s，否则Android会弹出超时dialog。
### BroadcastReceiver 的广播类型与不同的注册方式的区别

注册BroadcastReceiver有两种方式:

静态注册：在AndroidManifest.xml中用标签生命注册，并在标签内用标签设置过滤器。
```
    <receiver android:name="myRecevice">    //继承BroadcastReceiver，重写onReceiver方法
    
        <intent-filter>    
        
            <action android:name="com.dragon.net"></action> //使用过滤器，接收指定action广播
        
        </intent-filter>
    
    </receiver> 
```
    

动态注册：
```
    IntentFilter intentFilter = new IntentFilter();
    
    intentFilter.addAction(String);   //为BroadcastReceiver指定action，使之用于接收同action的广播
    
    registerReceiver(BroadcastReceiver,intentFilter);
    
    一般：在onStart中注册，onStop中取消unregisterReceiver
    指定广播目标Action：Intent intent = new Intent(actionString);
    并且可通过Intent携带消息 :intent.putExtra("msg", "hi,我通过广播发送消息了");
    发送广播消息：Context.sendBroadcast(intent )
```



## ContentProvider

## Service的使用场景与具体用法

#### service的种类

##### 按运行地点分类：

类别|	区别|	 优点|	缺点| 	 应用
---|---|---|---|---
本地服务（Local）|	该服务依附在主进程上，|	 服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应bindService会方便很多|。	 主进程被Kill后，服务便会终止。|	 非常常见的应用如：HTC的音乐播放服务，天天动听音乐播放服务。
远程服务（Remote）|	该服务是独立的进程，|	 服务为独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。	| 该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。	 |一些提供系统服务的Service，这种Service是常驻的。
其实remote服务还是很少见的，并且一般都是系统服务。

  

##### 按运行类型分类：

类别	|区别|	应用
---|---|---
前台服务|	会在通知一栏显示 ONGOING 的 Notification，|	当服务被终止的时候，通知一栏的 Notification 也会消失，这样对于用户有一定的通知作用。常见的如音乐播放服务。
后台服务|	默认的服务即为后台服务，即不会在通知一栏显示 ONGOING 的 Notification。|	当服务被终止的时候，用户是看不到效果的。某些不需要运行或终止提示的服务，如天气更新，日期同步，邮件同步等。
有同学可能会问，后台服务我们可以自己创建 ONGOING 的 Notification 这样就成为前台服务吗？答案是否定的，前台服务是在做了上述工作之后需要调用 startForeground （ android 2.0 及其以后版本 ）或 setForeground （android 2.0 以前的版本）使服务成为 前台服务。这样做的好处在于，当服务被外部强制终止掉的时候，ONGOING 的 Notification 任然会移除掉。

 

##### 按使用方式分类：

类别|区别
---|---
startService 启动的服务|	主要用于启动一个服务执行后台任务，不进行通信。停止服务使用stopService
bindService 启动的服务|	该方法启动的服务要进行通信。停止服务使用unbindService
startService 同时也 bindService 启动的服务	停止服务应同时使用stepService与unbindService


##### Service和Thread的关系
Service和Thread之间没有任何关系！
Service其实是运行在主线程里的.

## 动画相关也是必须掌握的，不管是矢量动画还是属性动画的api都应该熟练，一些简单的动画应该随手就能写出来才行。

## 自定义View

## Sqlite与SQL语句

常见的数据格式与解析方法得了解吧，虽然目前常用的数据格式就是json，解析库也有很多，如Gson、Jackson、Fastjson等。

## 网络编程相关的基础知识要掌握
http协议相关
http method<br/>
status code<br/>
request & response<br/>
http cache<br/>
request header<br/>
params<br/>
试着用 HttpUrlConnection 封装一个网络库<br/>
